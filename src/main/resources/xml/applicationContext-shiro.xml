<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  
">

	<!-- 配置ShiroFilter -->
	<!-- id必须和web.xml中配置的DelegatingFilterProxy的<filter-name>一致。 如果不一致，会抛出NoSuchBeanDefinitionException异常，因为shiro会在IOC容器中查找名称和<filter-name> 
		值一致的filter bean -->
	<bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
		<property name="securityManager" ref="securityManager" />
		<property name="loginUrl" value="/system/login.shtml" />
		<!-- 登入成功后直接跳转到用户首页 -->
		<property name="successUrl" value="/user/index.shtml" />
		<!-- 没有权限跳转页面 -->
		<property name="unauthorizedUrl" value="/error/unAuthorization.shtml" />
		<property name="filters">
            <map>
                <entry key="authc" value-ref="authenticationFilter"/>
                <entry key="authc" value-ref="loginSuccessReturnUrl"/>
            </map>
        </property>
		<!-- 配置哪些页面需要受保护，以及访问这些页面需要的权限 -->
		<property name="filterChainDefinitions">
			<value>
				<!-- anon表示此地址不需要任何权限即可访问 -->
				/plugins/**=anon
				/static/**=anon
				/system/*.shtml=anon
				/error/*.shtml=anon
				<!--所有的请求(除去配置的静态资源请求或请求地址为anon的请求)都要通过登录验证,如果未登录则跳到/login -->
				/**=user
			</value>
		</property>
	</bean>
	
	
	<!-- 配置SecurityManager -->
	<bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
		<property name="realms">
            <list>
                <ref bean="shiroRealm"/>
            </list>
        </property>
		<!--可选项 默认使用ServletContainerSessionManager，直接使用容器的HttpSession，可以通过配置sessionManager，使用DefaultWebSessionManager来替代-->
		<property name="sessionManager" ref="sessionManager"/>
		<!--可选项 最好使用;SessionDao 中 doReadSession 读取过于频繁了-->
		<property name="cacheManager" ref="shiroEhcacheManager"/>
	</bean>
	
	<bean id="shiroRealm" class="com.ofhi.common.security.shiro.shiroRealm" >
		 <!-- 配置密码匹配器 -->
        <property name="credentialsMatcher">
            <bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">
                <!-- 加密算法为MD5 -->
                <property name="hashAlgorithmName" value="MD5"></property>
                <!-- 加密次数 -->
                <property name="hashIterations" value="10"></property>
            </bean>
		</property>
	</bean>

	
	<!-- 缓存管理器 使用redis实现 -->
    <bean id="cacheManager" class="com.ofhi.common.cache.redis.RedisCacheManager">
        <property name="redisTemplate" ref="redisTemplate"/>
    </bean>

	<!-- 会话管理器 -->
	<bean id="redisSessionDAO" class="com.ofhi.common.cache.redis.RedisSessionDao">
		<property name="redisTemplate" ref="redisTemplate" />
	</bean>
 	<bean id="sessionManager" class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager">
		<!-- 设置全局会话超时时间，默认30分钟(1800000) -->
		<property name="globalSessionTimeout" value="1800000"/>
		<!-- 是否在会话过期后会调用SessionDAO的delete方法删除会话 默认true-->
		<property name="deleteInvalidSessions" value="false"/>
		<!-- 是否开启会话验证器任务 默认true -->
		<property name="sessionValidationSchedulerEnabled" value="false"/>
		<!-- 会话验证器调度时间 -->
		<property name="sessionValidationInterval" value="1800000"/>
		<property name="sessionFactory" ref="sessionFactory"/>
		<property name="sessionDAO" ref="cachingShiroSessionDao"/>
		<!-- 默认JSESSIONID，同tomcat/jetty在cookie中缓存标识相同，修改用于防止访问404页面时，容器生成的标识把shiro的覆盖掉 -->
		<property name="sessionIdCookie">
			<bean class="org.apache.shiro.web.servlet.SimpleCookie">
				<constructor-arg name="name" value="SHRIOSESSIONID"/>
			</bean>
		</property>
		<property name="sessionListeners">
			<list>
				<ref bean="sessionListener"/>
			</list>
		</property>
    </bean>

	<!-- 自定义Session工厂方法 返回会标识是否修改主要字段的自定义Session-->
	<bean id="sessionFactory" class="com.ofhi.common.cache.shiro.ShiroSessionFactory"/>


	<!--缓存管理器-->
	<!-- 用户授权信息Cache, 采用EhCache，本地缓存最长时间应比中央缓存时间短一些，以确保Session中doReadSession方法调用时更新中央缓存过期时间 -->
	<bean id="shiroEhcacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager">
		<property name="cacheManagerConfigFile" value="classpath:/xml/cache/ehcache-shiro.xml" />
	</bean>

	<bean id="sessionListener"  class="com.ofhi.common.Listener.ShiroSessionListener">
		<property name="sessionDao" ref="cachingShiroSessionDao" />
		<property name="shiroSessionService" ref="shiroSessionService"/>
	</bean>


	<bean id="cachingShiroSessionDao"  class="com.ofhi.common.cache.shiro.CachingShiroSessionDao">
		<property name="sessionRepository" ref="shiroSessionRepository"/>
	</bean>


	<bean id="shiroSessionRepository" class="com.ofhi.common.cache.shiro.ShiroSessionRepository">
		<property name="redisTemplate" ref="redisTemplate" />
	</bean>


	<bean id="shiroSessionService"  class="com.ofhi.common.cache.shiro.ShiroSessionService">
		<property name="redisTemplate" ref="redisTemplate" />
		<property name="sessionDao" ref="cachingShiroSessionDao" />
	</bean>


	<bean id="session" class="org.apache.shiro.web.servlet.SimpleCookie">
		<constructor-arg name="name" value="SESSIONID"/>
	</bean>

	<!--
	定时清理僵尸session，Shiro会启用一个后台守护线程定时执行清理操作
	用户直接关闭浏览器造成的孤立会话
	-->
	<bean id="sessionValidationScheduler"
		  class="org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler">
		<property name="interval" value="3600000"/>
		<property name="sessionManager" ref="sessionManager"/>
	</bean>

	<!-- 重写登入验证 -->
 	<bean id="authenticationFilter" class="com.ofhi.common.security.shiro.ShiroAuthenticationFilter"/>

	<bean id="loginSuccessReturnUrl" class="com.ofhi.common.security.shiro.LoginSuccessReturnUrlFilter"/>

	<!-- 配置LifecycleBeanPostProcessor，可以自定义地来调用配置在Spring IOC容器中shiro bean的生命周期方法 -->
	<bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor" />

	<!-- 使能够在IOC容器中使用shiro的注解，但必须在配置了LifecycleBeanPostProcessor之后才可以使用 -->
	<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor">
		<!-- 指定使用cglib动态代理, 因为jdk动态代理只是针对接口实现的 -->
		<property name="proxyTargetClass" value="true" />
	</bean>
	<bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
		<property name="securityManager" ref="securityManager" />
	</bean>
</beans> 